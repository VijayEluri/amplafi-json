/*
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy
 * of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed
 * under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
 * OR CONDITIONS OF ANY KIND, either express or implied. See the License for
 * the specific language governing permissions and limitations under the
 * License.
 */
package org.amplafi.flow.translator;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

import org.amplafi.flow.DataClassDefinition;
import org.amplafi.flow.FlowException;
import org.amplafi.flow.FlowPropertyDefinition;
import org.amplafi.flow.FlowTranslatorResolver;
import org.amplafi.flow.flowproperty.FlowPropertyProvider;
import org.amplafi.flow.json.IJsonWriter;
import org.amplafi.flow.json.JsonRenderer;
import org.amplafi.flow.validation.FlowValidationException;
import org.apache.commons.collections.list.SetUniqueList;

import com.sworddance.util.ApplicationIllegalArgumentException;

import static com.sworddance.util.CUtilities.*;

/**
 *
 * @author patmoore
 *
 * @param <T> class being translated.
 */
public abstract class AbstractFlowTranslator<T> implements FlowTranslator<T> {
    private FlowTranslatorResolver flowTranslatorResolver;
    protected List<Class<?>> serializedFormClasses = SetUniqueList.decorate(new ArrayList<Class<?>>());
    private List<Class<?>> deserializedFormClasses = SetUniqueList.decorate(new ArrayList<Class<?>>());
    private boolean flowTranslatorJsonRenderer;
    private JsonRenderer<T> jsonRenderer;

    @SuppressWarnings("unchecked")
    protected static final FlowTranslator<CharSequence> DEFAULT_FLOW_TRANSLATOR = CharSequenceFlowTranslator.INSTANCE;

    @SuppressWarnings("unchecked")
    protected AbstractFlowTranslator(AbstractFlowTranslator<?> flowTranslator) {
        this.flowTranslatorResolver = flowTranslator.getFlowTranslatorResolver();
        this.deserializedFormClasses.addAll(flowTranslator.deserializedFormClasses);
        this.serializedFormClasses.addAll(flowTranslator.serializedFormClasses);
        this.flowTranslatorJsonRenderer = flowTranslator.flowTranslatorJsonRenderer;
        this.jsonRenderer = (JsonRenderer<T>) flowTranslator.jsonRenderer;
    }
    protected AbstractFlowTranslator() {
        serializedFormClasses.add(CharSequence.class);
        serializedFormClasses.add(String.class);
        this.flowTranslatorJsonRenderer = JsonRenderer.class.isAssignableFrom(this.getClass());
    }

    /**
     * @param jsonRenderer
     */
    public AbstractFlowTranslator(JsonRenderer<T> jsonRenderer) {
        this();
        this.jsonRenderer = jsonRenderer;
    }

    /**
     * @see org.amplafi.flow.translator.FlowTranslator#deserialize(FlowPropertyProvider , org.amplafi.flow.FlowPropertyDefinition , org.amplafi.flow.DataClassDefinition, java.lang.Object)
     */
    @SuppressWarnings("unchecked")
    @Override
    public T deserialize(FlowPropertyProvider flowPropertyProvider, FlowPropertyDefinition flowPropertyDefinition, DataClassDefinition dataClassDefinition, Object serializedObject) throws FlowException {
        if ( serializedObject == null ) {
            return null;
        } else if ( isDeserializedForm(serializedObject.getClass())) {
            return (T) serializedObject;
        } else {
            return doDeserialize(flowPropertyProvider, flowPropertyDefinition, dataClassDefinition, serializedObject);
        }
    }

    @Override
    public final <W> W serialize(FlowPropertyDefinition flowPropertyDefinition, DataClassDefinition dataClassDefinition, W outputWriter, T object) {
        W jsonWriter;
        if ( outputWriter == null ) {
            jsonWriter = getJsonWriter();
        } else {
            jsonWriter = outputWriter;
        }

        if ( object == null ) {
            // if jsonWriter is expecting a value ( because it just had a key set ) then we need to serialize a null.
            // TODO: investigate serializing a null.
            return jsonWriter;
        } else if ( this.isSerializedForm(object.getClass())) {
            // already in a serialized form? (we hope )
            return (W) ((IJsonWriter)jsonWriter).value(object);
        } else {
            return (W) doSerialize(flowPropertyDefinition, dataClassDefinition, (IJsonWriter) jsonWriter, object);
        }
    }
    /**
     * @return a JsonWriter (generated by {@link org.amplafi.flow.FlowTranslatorResolver} usually )
     */
    protected <W> W getJsonWriter() {
        return (W) flowTranslatorResolver.getJsonWriter();
    }
    /**
     * @param jsonWriter
     * @param object
     * @return jsonWriter
     */
    @SuppressWarnings("unused")
    protected IJsonWriter doSerialize(FlowPropertyDefinition flowPropertyDefinition, DataClassDefinition dataClassDefinition, IJsonWriter jsonWriter, T object) {
        toJson(jsonWriter, object);
        return jsonWriter;
    }

    @SuppressWarnings({"unused","unchecked"})
    protected T doDeserialize(FlowPropertyProvider flowPropertyProvider, FlowPropertyDefinition flowPropertyDefinition, DataClassDefinition dataClassDefinition, Object serializedObject) throws FlowValidationException {
        return (T) fromJson(serializedObject);
    }

    @SuppressWarnings("unused")
    public boolean isSerializable(FlowPropertyDefinition flowPropertyDefinition, DataClassDefinition dataClassDefinition, Object value) {
        if ( value == null ) {
            return true;
        } else {
            return isAssignableFrom(value.getClass());
        }
    }
    @Override
    public boolean isAssignableFrom(Class<?> differentClass) {
        if ( getTranslatedClass().isAssignableFrom(differentClass)) {
            return true;
        } else {
            for(Class<?> clazz: this.serializedFormClasses) {
                if (clazz.isAssignableFrom(differentClass) ) {
                    return true;
                }
            }
            for(Class<?> clazz: this.getDeserializedFormClasses()) {
                if (clazz.isAssignableFrom(differentClass) ) {
                    return true;
                }
            }
            return false;
        }
    }

    @Override
    public boolean isDeserializable(FlowPropertyDefinition flowPropertyDefinition, DataClassDefinition dataClassDefinition, Object value) {
        if ( value == null ) {
            return true;
        } else {
            return isAssignableFrom(value.getClass());
        }
    }

    @Override
    public T getDefaultObject(FlowPropertyProvider flowPropertyProvider) {
        return null;
    }
    protected void addSerializedFormClasses(Class<?>... clazz) {
        this.serializedFormClasses.addAll(Arrays.asList(clazz));
    }
    protected void addDeserializedFormClasses(Class<?>... clazz) {
        Collections.addAll(this.deserializedFormClasses,clazz);
    }
    @Override
    public boolean isDeserializedForm(Class<?> clazz) {
        return clazz == getTranslatedClass() || deserializedFormClasses.contains(clazz);
    }
    public boolean isSerializedForm(Class<?> clazz) {
        return serializedFormClasses.contains(clazz);
    }
    public void setDeserializedFormClasses(List<Class<?>> deserializedFormClasses) {
        this.deserializedFormClasses.clear();
        if ( isNotEmpty(deserializedFormClasses)) {
            this.deserializedFormClasses.addAll(deserializedFormClasses);
        }
    }

    @Override
    public List<Class<?>> getDeserializedFormClasses() {
        if ( !deserializedFormClasses.contains(getTranslatedClass())) {
            deserializedFormClasses.add(getTranslatedClass());
        }
        return deserializedFormClasses;
    }

    /**
     * NOTE: May be overridden!
     * @see org.amplafi.flow.translator.FlowTranslator#getTranslatedClass()
     */
    @Override
    public Class<?> getTranslatedClass() {
        return jsonRenderer.getClassToRender();
    }

    /**
     * @param jsonWriter
     * @param object
     * @return TODO
     */
    public IJsonWriter toJson(IJsonWriter jsonWriter, T object) {
        ApplicationIllegalArgumentException.valid(this != jsonRenderer, this,":infinite loop jsonRenderer==this");

        return jsonRenderer.toJson(jsonWriter, object);
    }

    /**
     * @param <K>
     * @param serializedObject
     * @return the deserialized (from json) value.
     */
    @SuppressWarnings("unchecked")
    public <K> K fromJson(Object serializedObject) {
        return (K) jsonRenderer.fromJson(getTranslatedClass(), serializedObject);
    }

    /**
     * @return the jsonRenderer
     */
    @SuppressWarnings("unchecked")
    @Override
    public JsonRenderer<T> getJsonRenderer() {
        return jsonRenderer == null && this.flowTranslatorJsonRenderer? (JsonRenderer<T>)this : jsonRenderer ;
    }

    protected void setJsonRenderer(JsonRenderer<T> jsonRenderer) {
        this.jsonRenderer = jsonRenderer;
    }

    /**
     * @param flowTranslatorResolver the flowTranslatorResolver to set
     */
    public void setFlowTranslatorResolver(FlowTranslatorResolver flowTranslatorResolver) {
        this.flowTranslatorResolver = flowTranslatorResolver;
    }

    /**
     * @return the flowTranslatorResolver
     */
    public FlowTranslatorResolver getFlowTranslatorResolver() {
        return flowTranslatorResolver;
    }
}
